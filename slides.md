---
theme: seriph
background: https://images.unsplash.com/photo-1541029071515-84cc54f84dc5?q=80&w=1080&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D
title: Programaci√≥n Din√°mica
info: |
  ## T√©cnicas avanzadas de optimizaci√≥n
  Explorando estrategias de bottom-up y top-down.
class: text-center
highlighter: shiki
drawings:
  persist: false
lineNumbers: true
transition: fade-out
mdc: true
addons:
  - slidev-addon-asciinema
---

# Programaci√≥n Din√°mica

Trade-offs entre tiempo-espacio.

---
layout: two-cols
---
# ¬øQu√© es la Programaci√≥n Din√°mica?
Primer acercamiento

La Programaci√≥n Din√°mica (PD) es una t√©cnica para resolver problemas complejos al descomponerlos en subproblemas m√°s manejables.

Trata de evitar la repetici√≥n de c√°lculos resolviendo cada subproblema <span v-mark="{ at: 1, color: 'red', type: 'underline' }">una sola vez</span>.

::right::


<v-switch>
  <template #2>
      Vamos a tranformar esto:
      <img src="/dp_google.jpg" class="absolute top-40 w-120" /> 
  </template>
  <template #3>
      En esto:
      <div class="flex items-center justify-center w-full h-full">
        <Tweet id="1640394252940369923" scale=0.9 />
      </div>
  </template>
</v-switch>


---
layout: image-right

# the image source
image: /bellman.jpeg
---

# Inicios
Bellman y su legado

El t√©rmino **"Programaci√≥n Din√°mica"** fue acu√±ado por **Richard Bellman** en los a√±os 50, marcando un hito en el campo de la optimizaci√≥n matem√°tica.

Bellman tambi√©n es conocido por su trabajo en teor√≠a de juegos y aprendizaje por refuerzo.

---

# Principios Fundamentales
Condiciones presentes en la PD

1. **Subestructura √≥ptima üõ†Ô∏è** 

La soluci√≥n de subproblemas m√°s peque√±os puede utilizarse para abordar el problema global.

<br>

2. **Subproblemas superpuestos üîÅ**

Problemas que pueden descomponerse en partes que se resuelven repetidamente.

---

# Subestructura √≥ptima üõ†Ô∏è
Deseable en la PD

La subestructura √≥ptima significa que una soluci√≥n √≥ptima de un problema puede ser construida a partir de soluciones √≥ptimas de sus subproblemas. Este principio es esencial para garantizar que la estrategia de combinar las soluciones de los subproblemas conduce a una soluci√≥n √≥ptima del problema global.


Ejemplos: 
- Merge Sort: Utiliza la subestructura √≥ptima para combinar dos listas ordenadas.
- Fibonacci: Utiliza los dos elementos anteriores para calcular el siguiente.

<br>

> ¬øD√≥nde hemos visto esto antes?

---

# Subproblemas superpuestos üîÅ
Requsito en la PD

Los subproblemas superpuestos se refieren a la situaci√≥n en la que los subproblemas se repiten varias veces, lo que significa que una soluci√≥n simple basada en la divisi√≥n del problema en subproblemas y su soluci√≥n independiente ser√≠a ineficiente debido a la repetici√≥n del trabajo.

<br>

> Mientras que la subestructura √≥ptima es deseable, la superposici√≥n de subproblemas es esencial para la PD. 

<br>

> Pregunta: ¬øQu√© ocurre si no se cumple la propiedad de subproblemas superpuestos?

---

# Fibonacci
Hola mundo de la PD

$$
F(n) = 
\begin{cases} 
0 & \text{si } n = 0,\\
1 & \text{si } n = 1,\\
F(n-1) + F(n-2) & \text{si } n > 1.
\end{cases}
$$


<v-switch>
  <template #1>
      <div class="flex justify-center">
        <img src="/fibo.png" class="w-100" />
      </div>
  </template>
  <template #2>
      <div class="flex justify-center">
        <img src="/fibo_2.png" class="w-100" />
      </div>
  </template>
</v-switch>

<div v-click="1">
  <p>Preguntas:</p>
    <ul>
        <li>¬øD√≥nde se aprecia la subestructura √≥ptima?</li>
        <li>¬øD√≥nde se repiten los subproblemas?</li>
    </ul>
</div>

---
layout: two-cols
---

<<< @/snippets/fibo_rec.cpp {all|8-11|13-34|16|19|22|25|30-31|all}{maxHeight:'500px'}


::right::

<v-click>
  <Asciinema src="./casts/fibo-rec.cast" :playerProps="{speed: 2, rows: 30}"/>
</v-click>

<v-clicks>

- ¬øQu√© complejidad tiene la funci√≥n `fibo`?
- ¬øQu√© ocurre si se calcula `fibo(50)`?

</v-clicks>

---
layout: intro
---

# ¬øC√≥mo podemos mejorar la eficiencia de Fibonacci? ü§î

---
layout: two-cols-header
---

# T√©cnicas de Programaci√≥n Din√°mica
Dos enfoques

Existen dos enfoques principales para implementar la Programaci√≥n Din√°mica. Ambos comparten el objetivo de evitar la repetici√≥n de c√°lculos, pero difieren en la forma en que lo hacen.

::left::

# Memoizaci√≥n
(Top-Down)

Se basa en almacenar los resultados de los subproblemas en una estructura de datos, como un diccionario, o arrays (de N dimensiones) para evitar recalcularlos.

::right::

# Tabulaci√≥n
(Bottom-Up)

Se basa en resolver los subproblemas en un orden espec√≠fico y almacenar los resultados en una tabla, generalmente un array, para que puedan ser utilizados en la resoluci√≥n de problemas m√°s grandes.

---

# Memoizaci√≥n (Top-Down)
F√°cil de implementar

En caso de tener una funci√≥n recursiva, se puede utilizar la memoizaci√≥n para almacenar los resultados de los subproblemas en una estructura de datos, como un diccionario u array, para evitar recalcularlos.

Es **top-down** porque se resuelven los subproblemas m√°s grandes primero y se utilizan para resolver los subproblemas m√°s peque√±os.

<v-click>
````md magic-move
```cpp
int fibo(int n) {
    if (n <= 1) return n;
    return fibo(n - 1) + fibo(n - 2);
}
```
```cpp {*|1|3|4|*}
int fibo(int n, int* memo) {
    if (n <= 1) return n;
    if (memo[n] != -1) return memo[n];
    memo[n] = fibo(n - 1, memo) + fibo(n - 2, memo);
    return memo[n];
}
```
````

</v-click>

<v-clicks>

- ¬øQu√© ventajas tiene la memoizaci√≥n sobre la recursi√≥n simple?
- ¬øQu√© desventajas tiene la memoizaci√≥n?
- ¬øQu√© complejidad tiene la funci√≥n `fibo` con memoizaci√≥n?
- ¬øCu√°l es el "costo" de la memoizaci√≥n?
- ¬øQu√© valores iniciales deber√≠a tener el array `memo`?

</v-clicks>

<!-- $O(2^n)$ es el orden sin memo -->

---

# Tabulaci√≥n (Bottom-Up)
Enfoque imperativo

La tabulaci√≥n es un enfoque iterativo que implica resolver los subproblemas en un orden espec√≠fico y almacenar los resultados en una tabla, generalmente un array, para que puedan ser utilizados en la resoluci√≥n de problemas m√°s grandes.

Es bottom-up porque se resuelven los subproblemas m√°s peque√±os primero y se utilizan para resolver los subproblemas m√°s grandes.

<v-click>
````md magic-move
```cpp
int fibo(int n) {
    if (n <= 1) return n;
    return fibo(n - 1) + fibo(n - 2);
}
```
```cpp {*|2|3-4|5-7|8|*}
int fibo(int n) {
    int tab[n + 1];
    tab[0] = 0;
    tab[1] = 1;
    for (int i = 2; i <= n; i++) {
        tab[i] = tab[i - 1] + tab[i - 2];
    }
    return tab[n];
}
```
```cpp
int fibo(int n) {
    if (n <= 1) return n;
    int lastlast = 0, last = 1, current;
    for (int i = 2; i <= n; i++) {
        current = lastlast + last;
        lastlast = last;
        last = current;
    }
    return current;
}
```
```
````
</v-click>

<v-clicks>

- ¬øQu√© ventajas tiene la tabulaci√≥n sobre la memoizaci√≥n?
- ¬øQu√© complejidad tiene la funci√≥n `fibo` con tabulaci√≥n?

</v-clicks>

---

# Problema: escaleras
Un problema ya conocido...

Dada una escalera con `n` escalones, se puede subir de a 1 o 2 escalones a la vez. ¬øCu√°ntas formas distintas hay de subir la escalera?

<v-clicks>

- En el escal√≥n 0, ¬øcu√°ntas formas hay de subir?
- En el escal√≥n 1, ¬øcu√°ntas formas hay de subir?
- En el escal√≥n 2, ¬øcu√°ntas formas hay de subir?
- En el escal√≥n 3, ¬øcu√°ntas formas hay de subir?
- ¬øC√≥mo se relacionan los subproblemas?

</v-clicks>

<v-click>

Secreto: Dejar de pensar como vamos a subir la escalera y pensar en c√≥mo llegamos al √∫ltimo escal√≥n.

<img src="/blowmind.gif" class="absolute bottom-0 right-0 w-50" />

</v-click>

---

# Problema: escaleras ponderadas
Un problema m√°s complejo

Dada una escalera con `n` escalones, se puede subir de a 1, 2 escalones a la vez. Cada escal√≥n tiene un peso asociado (siempre positivo). ¬øCu√°l es la suma de los pesos de la secuencia de escalones que minimiza el peso total?


<v-clicks>

- ¬øC√≥mo se relacionan los subproblemas?
- ¬øC√≥mo puedo saber el camino que recorr√≠?

</v-clicks>

--- 

# Problema: caminos (matriz)
Un problema de combinatorias

Dada una matriz de `m x n`, ¬øcu√°ntos caminos distintos hay para llegar de la esquina superior izquierda a la esquina inferior derecha?

Nos movemos hacia abajo o hacia la derecha.

<table style="width:100%; border: 1px solid white; border-collapse: collapse;">
  <tr>
    <td style="border: 1px solid white; padding: 10px;">I</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
  </tr>
  <tr>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
  </tr>
  <tr>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">F</td>
  </tr>
</table>


---

# Problema: caminos con obst√°culos
Un problema m√°s complejo

Dada una matriz de `m x n` con obst√°culos, ¬øcu√°ntos caminos distintos hay para llegar de la esquina superior izquierda a la esquina inferior derecha?

Nos movemos hacia abajo o hacia la derecha.

<table style="width:100%; border: 1px solid white; border-collapse: collapse;">
  <tr>
    <td style="border: 1px solid white; padding: 10px;">I</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
  </tr>
  <tr>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">üíÄ</td>
    <td style="border: 1px solid white; padding: 10px;">üíÄ</td>
  </tr>
  <tr>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">-</td>
    <td style="border: 1px solid white; padding: 10px;">F</td>
  </tr>
</table>

---

# Problema: problema del cambio
Un problema de optimizaci√≥n

Dada una cantidad `amount` y un conjunto de monedas de denominaciones `coins`, ¬øcu√°l es la menor cantidad de monedas que se necesitan para devolver el cambio?

Ejemplo:
- Monedas: [1, 2, 5, 10, 50]
  - Para cambio de 12 pesos -> 2 monedas (10, 2)
  - Para cambio de 47 pesos -> 6 monedas (10, 10, 10, 10, 5, 2)
- Monedas: [1, 2, 5, 12, 50] üëÄ
  - Para cambio de 15 pesos -> 2 monedas (10, 5) ‚úîÔ∏è

---

# Problema: combinatorias
Tri√°ngulo de Pascal



Definici√≥n:

$$ \binom{n}{k} = \frac{n!}{k!(n-k)!} $$

De forma recursiva:

$$ 
\begin{cases}
\binom{n}{0} = 1 \\
\binom{n}{n} = 1 \\
\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}
\end{cases}
$$


---

# Problema: mochila
Cl√°sico de cl√°sicos

Recordemos la soluci√≥n de la mochila 0-1 con dividir y conquistar.

```cpp
int knapsack(int W, int wt[], int val[], int n) {
    if (n == 0 || W == 0) return 0;
    if (wt[n - 1] > W) return knapsack(W, wt, val, n - 1);
    return max(val[n - 1] + knapsack(W - wt[n - 1], wt, val, n - 1),
               knapsack(W, wt, val, n - 1));
}
```

<br>

> Pregunta: ¬øExiste una subestructura √≥ptima en este problema?


---

# Problema: otras mochila 
Otros tipos

- Mochila 0-INF
- Mochila 0-N
- Mochila de dos o m√°s dimensiones
